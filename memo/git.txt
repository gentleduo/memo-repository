github账号:gentleduo@163.com
github密码:lzd830319

生成SSH Key：
ssh-keygen -t rsa -b 2048 -C "gentleduo@163.com"
回车后输出如下:
Generating public/private rsa key pair. 
Enter file in which to save the key (/Users/your_user_name/.ssh/id_rsa):
直接回车，会将key保存到默认文件中。
接着会输出：
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
这两步是让你输入一个密码，以及确认密码，这个密码在你提交代码到Github时会用到【注意：记住这个密码，最简单的方式就是设置的和github账户登入密码一样，容易记住】
回车后就提示成功了：
Your identification has been saved in /Users/your_user_name/.ssh/id_rsa. 
Your public key has been saved in /Users/your_user_name/.ssh/id_rsa.pub. 
The key fingerprint is: 
01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com 
到这一步，你会发现/Users/your_user_name/.ssh/id_rsa.pub文件已经生成了

成功的话会在~/下生成.ssh文件夹，进去，打开id_rsa.pub，复制里面的key。回到github上，进入Account=>Settings（账户配置）
左边选择SSH and GPG keys，然后点击New SSH key按钮,title设置标题，可以随便填，粘贴在你电脑上生成的key。

把ssh添加到keychain中
这个时候如果去git clone代码，会让你输入密码。解决方法就是添加到keychain中：
ssh-add -K /Users/youre_user_name/.ssh/id_rsa 

git@github.com:gentleduo/source-repository.git

############################################################Git 配置############################################################
Git 提供了一个叫做 git config 的工具，专门用来配置或读取相应的工作环境变量。
这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：
    /etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 --system 选项，读写的就是这个文件。
    ~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 --global 选项，读写的就是这个文件。
    当前项目的 Git 目录中的配置文件（也就是工作目录中的 .git/config 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆盖 /etc/gitconfig 中的同名变量。

用户信息
Git 为你的每一个提交都记录你的名字与电子邮箱地址，所以第一步需要配置用户名和邮箱地址：
$ git config --global user.name "gentleduo"
$ git config --global user.email gentleduo@163.com
如果用了 --global 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。
如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 --global 选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。

文本编辑器
设置Git默认使用的文本编辑器, 一般可能会是 Vi 或者 Vim。如果你有其他偏好，比如 Emacs 的话，可以重新设置：:
$ git config --global core.editor emacs 

差异分析工具
还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。比如要改用 vimdiff 的话：
$ git config --global merge.tool vimdiff
Git 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。

查看配置信息
要检查已有的配置信息，可以使用 git config --list 命令：
$ git config --list
http.proxy=socks5://127.0.0.1:1080
user.email=gentleduo@163.com
user.name=gentleduo
有时候会看到重复的变量名，那就说明它们来自不同的配置文件（比如 /etc/gitconfig 和 ~/.gitconfig），不过最终 Git 实际采用的是最后一个。
也可以直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可，像这样：
$ git config user.name
gentleduo
############################################################Git 配置############################################################

###################################################Git 工作区、暂存区和版本库###################################################
工作区：就是你在电脑里能看到的目录。
暂存区：英文叫stage, 或index。一般存放在 ".git目录下" 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。
版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。

在版本库中标记为 "index" 的区域是暂存区（stage, index），标记为 "master" 的是 master 分支所代表的目录树。 

"HEAD" 实际是指向 master 分支的一个"游标"。命令中出现 HEAD 的地方可以用 master 来替换。 

objects 标识的区域为 Git 的对象库，实际位于 ".git/objects" 目录下，里面包含了创建的各种对象及内容。

当对工作区修改（或新增）的文件执行"git add" 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。

当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。 

当执行 "git reset HEAD" 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。 

当执行 "git rm --cached <file>" 命令时，会直接从暂存区删除文件，工作区则不做出改变。

当执行 "git checkout ." 或者 "git checkout -- <file>" 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。 

当执行 "git checkout HEAD ." 或者 "git checkout HEAD <file>" 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。


                        checkout 
   ---------------------------------------------------
   |                                                 |
   |                    rm-cached                    |
   |          add                    commit          |
工作区  -------------->  暂存区  -------------->  版本库
   |    <--------------     |    <--------------     |
   |	  checkout          |     reset/checkout     |
   |                        |                        |
   ∨                        ∨                        ∨
   ---------------------------------------------------
                     status\relog\rm
###################################################Git 工作区、暂存区和版本库###################################################

##########################################################Git 创建仓库##########################################################
git init
Git使用git init命令来初始化一个Git仓库，Git的很多命令都需要在Git的仓库中运行，所以git init是使用Git的第一个命令。你可以在任何时候、任何目录中这么做，完全是本地化的。在执行完成git init命令后，Git仓库会生成一个.git目录，该目录包含了资源的所有元数据，其他的项目目录保持不变（不像SVN会在每个子目录生成.svn目录，Git只在仓库的根目录生成.git目录）。Git 的工作就是创建和保存你项目的快照及与之后的快照进行对比。

使用方法
使用当前目录作为Git仓库，我们只需使它初始化。
git init
该命令执行完后会在当前目录生成一个.git目录。
使用我们指定目录作为Git仓库。
git init newrepo

初始化后，会在newrepo目录下会出现一个名为.git的目录，所有有关此项目的快照数据都存放在这里。
如果当前目录下有几个文件想要纳入版本控制，需要先用git add命令告诉Git开始对这些文件进行跟踪，然后提交：
$ git add *.c
$ git add README
$ git commit -m '初始化项目版本'
以上命令将目录下以.c结尾及README文件提交到仓库中。
git add .提交（某些版本中）无法提交删除的东西；必须使用git add --all ；

git remote
添加远程库：要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用,命令格式如下：
git remote add [shortname] [url]
要查看当前配置有哪些远程仓库，可以用命令（执行时加上 -v 参数，你还可以看到每个别名的实际链接地址。）：
$ git remote
origin
$ git remote -v
origin    git@github.com:tianqixin/runoob-git-test.git (fetch)
origin    git@github.com:tianqixin/runoob-git-test.git (push)

git pull
使用git pull来从远程仓库"同步"代码，通常有三种方式；
git pull <远程主机名> <远程分支名>:<本地分支名>
git pull origin <remote_branch>：<local_branch>
git pull origin <remote_branch>
git pull
1.git pull origin <remote_branch>：<local_branch>
这种用法写起来最为繁琐，但最好理解：
场景：当本地的当前分支不是local_branch；
作用：将远程分支拉取到指定本地分支；
例如：当前分支是dev，但是你想把远程master”同步”到本地master，但又不想使checkout切换到master分支；
这时你就可以使用git pull origin master：master
2.git pull origin <remote_branch>
有了上面的例子，这种使用方法的场景和作用就好理解了：
场景：在当前分支上进行同步操作；
作用：将指定远程分支同步到当前本地分支；
3.git pull
这种写法最简单，也最常用，但是隐含的知识也是最多的；
场景：本地分支已经和想要拉取的分支建立了“关联”关系；
作用：拉取所有远程分支的新版本"坐标"，并同步当前分支的本地代码(具体根据关联分支而定)

git push
使用push时，我们要特别注意分支的名称和”关联分支"对于操作的影响
git push
git push origin <remote_branch>
git push origin <local_branch>：<remote_branch>
git push <远程主机名> <本地分支名>:<远程分支名>
1.git push
场景：当前分支已经有关联分支，并且关联分支与当前分支同名；
作用：将当前分支代码同步到远程同名分支；
2.git push origin <remote_branch>
场景：同步指定分支(非当前分支)到远程分支,如果是当前分支则<local_branch>可以省略
作用："同步"指定的本地分支到远程关联同名分支；
3.git push origin <local_branch>：<remote_branch>
场景：将本地分支推送到远程不同名的分支；
作用：将指定的本地分支推送到指定的远程分支；（这两个分支并没有建立关联关系，且可以不同名）
首先git作为支持分布式版本管理的工具，它管理的库（repository）分为本地库、远程库。

注：
git commit操作的是本地库，git push操作的是远程库。
git commit是将本地修改过的文件提交到本地库中。
git push是将本地库中的最新信息发送给远程库。
区分本地commit和服务器的push的原因:
因为如果本地不commit的话，修改的纪录可能会丢失。
而有些修改当前是不需要同步至服务器的，所以什么时候同步过去由用户自己选择。什么时候需要同步再push到服务器

git clone
我们使用 git clone 从现有 Git 仓库中拷贝项目（类似 svn checkout）。
克隆仓库的命令格式为： 
git clone <repo>
如果我们需要克隆到指定的目录，可以使用以下命令格式：
git clone <repo> <directory>
参数说明：
repo:Git 仓库。
directory:本地目录。
比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令： 
$ git clone git://github.com/schacon/grit.git
执行该命令后，会在当前目录下创建一个名为grit的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录。
如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：
$ git clone git://github.com/schacon/grit.git mygrit

##########################################################Git 创建仓库##########################################################

##########################################################关联远程仓库##########################################################
什么是"关联"分支?
首先我们先使用git branch -vv 查看一下目前分支的“关联”情况；
$ git branch -vv
* dev    1a1b215 [origin/dev] Merge branch 'master' of https://github.com/jinxintang/gitTest into dev
  master a09fdc4 [origin/master] create pull 
可以看到我们的本地的dev关联的是远程(origin)的dev，本地的master关联的是远程(origin)的master;那么这种关联是如何建立、是否可以修改呢；
配置本地分支与远程分支的三种方法：
1.检出时建立关联关系：git checkout -b dev origin/dev
当我们检查时，git会自动为我们检出的分支和远程分支建立关联关系；
2.提交时配置关联关系：git push -u origin <remote_branch>或git push --set-upstream origin <remote_branch>
  方法一：
  1. 到github上在仓库Clone or download下拉列表中找到以git@github.com:开头的仓库SSH地址并复制（因为HTTPS较慢，一般用SSH地址）
  2. 在本地执行命令：
  git remote add origin 你复制的地址
  注意：如果远程仓库中有文件，本地第一次push之前需要执行：git pull origin master
  3. 执行关联命令：
  git push -u origin master
  注意：如果需要重新关联一个origin需要执行命令：
  git remote rm orgin
  git remote add origin xxxxx
  git push -u origin master
  方法二：
  1. 到github上在仓库Clone or download下拉列表中找到以git@github.com:开头的仓库SSH地址并复制（因为HTTPS较慢，一般用SSH地址）
  2. 在本地执行命令：
  git clone 你复制的地址
  该方法比较省力，省去了执行命令git remote add origin和git push -u origin master
  但如果重新关联的话还是要用到上面2条命令的
3.更改git/config文件：git branch --set-upstream-to=<remote_branch>
无论使用上述那种方法，本地分支和远程分支的“关联”最终都会写到config文件；注：本项目的配置信息存放目录：项目所在目录/.git/config
关联分支：在git中表现为upstream,无论是使用push -u 或是 git branch --set-upstream-to方法，均会将这种对应关系写入.git/config配置文件，
如果一个本地分支没有关联分支，则无法执行git push或git pull指令；（但是可以使用git pull origin <remote_branch>、git push origin <remote_branch>等）
没有"关联"分支的情况下，使用push会先让你设置一个upstream branch.
##########################################################关联远程仓库##########################################################

##############################################非快进方式合并没有共同历史的远程分支##############################################
方法一：
git pull origin master --allow-unrelated-histories --no-ff
方法二：
git配置过程中fatal:拒绝合并无关的历史
首先将远程仓库和本地仓库关联起来：
git branch --set-upstream-to=origin/master master
然后使用git pull整合远程仓库和本地仓库，
git pull --allow-unrelated-histories    (忽略版本不同造成的影响)
##############################################非快进方式合并没有共同历史的远程分支##############################################

##########################################################Git 基本操作##########################################################
基本快照
Git 的工作就是创建和保存你的项目的快照及与之后的快照进行对比。

git add
git add命令可将该文件添加到缓存，git status命令用于查看项目的当前状态。如我们添加以下两个文件：
$ touch README
$ touch hello.php
$ ls
README        hello.php
$ git status -s
?? README
?? hello.php
$ 
接下来我们执行git add命令来添加文件：
$ git add README hello.php 
现在我们再执行 git status，就可以看到这两个文件已经加上去了。
$ git status -s
A  README
A  hello.php
$ 
新项目中，添加所有文件很普遍，我们可以使用git add .命令来添加当前项目的所有文件。
现在我们修改 README 文件
$ vim README
在 README 添加以下内容：# Runoob Git 测试，然后保存退出。
再执行一下 git status：
$ git status -s
AM README
A  hello.php
"AM" 状态的意思是，这个文件在我们将它添加到缓存之后又有改动。改动后我们再执行git add命令将其添加到缓存中：
$ git add .
$ git status -s
A  README
A  hello.php
当你要将你的修改包含在即将提交的快照里的时候，需要执行git add。

git status
git status 以查看在你上次提交之后是否有修改。
加-s参数表示获得简短的结果输出。如果没加该参数会详细输出内容：
$ git status
On branch master
Initial commit
Changes to be committed:
  (use "git rm --cached <file>..." to unstage)
    new file:   README
    new file:   hello.php

git diff
执行git diff来查看执行git status的结果的详细信息。
git diff命令显示已写入缓存与已修改但尚未写入缓存的改动的区别。git diff有两个主要的应用场景。
    尚未缓存的改动：git diff
    查看已缓存的改动： git diff --cached
    查看已缓存的与未缓存的所有改动：git diff HEAD
    显示摘要而非整个 diff：git diff --stat
git status显示你上次提交更新后的更改或者写入缓存的改动， 而git diff一行一行地显示这些改动具体是啥。

git commit
使用git add命令将想要快照的内容写入缓存区，而执行git commit将缓存区内容添加到仓库中。
写入缓存，并提交所有改动。使用 -m 选项以在命令行中提供提交注释：
$ git commit -m '第一次版本提交'
记录了快照后再执行git status:
$ git status
# On branch master
nothing to commit (working directory clean)
以上输出说明我们在最近一次提交之后，没有做任何改动，是一个"working directory clean：干净的工作目录"。
如果你没有设置-m选项，Git会尝试为你打开一个编辑器以填写提交信息。 如果Git在你对它的配置中找不到相关信息，默认会打开vim。
如果觉得git add提交缓存的流程太过繁琐，Git也允许你用-a选项跳过这一步。命令格式如下：
git commit -a 例如：先修改文件内容；再执行以下命令：git commit -am '修改文件'

git reset HEAD
git reset HEAD 命令用于取消已缓存的内容。
例如：git reset HEAD hello.php  取消hello.php文件的缓存
现在执行git commit，只会将hello.php文件以为的文件的改动提交。
如要提交hello.php的修改可以使用如下命令：git commit -am '修改 hello.php 文件'
简而言之，执行git reset HEAD用来取消之前git add添加的但不希望包含在下一提交快照中的缓存。

git rm
如果只是简单地从工作目录中手工删除文件，运行git status时就会在Changes not staged for commit的提示。
要从Git中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交。可以用以下命令完成此项工作
git rm <file>
如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f
git rm -f <file>
如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 --cached 选项即可
git rm --cached <file>

git mv
git mv命令用于移动或重命名一个文件、目录、软连接。
例如：git mv README  README.md
##########################################################Git 基本操作##########################################################

##########################################################Git 分支管理##########################################################
分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。
创建分支命令：
git branch (branchname)
切换分支命令:（当你切换分支的时候，Git会用该分支的最后提交的快照替换你的工作目录的内容，所以多个分支不需要多个目录。）
git checkout (branchname)
合并分支命令:
git merge 

列出分支基本命令：
git branch
没有参数时，git branch 会列出你在本地的分支。
$ git branch
* master
此例的意思就是，我们有一个叫做master的分支，并且该分支是当前分支。
当你执行git init的时候，缺省情况下Git就会为你创建master分支。
如果我们要手动创建一个分支。执行git branch (branchname)即可。 
$ git branch testing
$ git branch
* master
  testing
现在可以看到，有了一个新分支testing。此时testing分支的内容跟master分支内容一致
当以此方式在上次提交更新之后创建了新分支，如果后来又有更新提交，然后又切换到了testing分支，Git 将还原你的工作目录到你创建分支时候的样子。 
接下来我们将演示如何切换分支，我们用git checkout (branch)切换到我们要修改的分支。
$ ls
README
$ echo 'runoob.com' > test.txt
$ git add .
$ git commit -m 'add test.txt'
[master 3e92c19] add test.txt
 1 file changed, 1 insertion(+)
 create mode 100644 test.txt
$ ls
README        test.txt
$ git checkout testing
Switched to branch 'testing'
$ ls
README
当我们切换到testing分支的时候，我们添加的新文件test.txt 被移除了。切换回master分支的时候，它们有重新出现了。
$ git checkout master
Switched to branch 'master'
$ ls
README        test.txt
也可以使用git checkout -b (branchname)命令来创建新分支并立即切换到该分支下，从而在该分支中操作。

删除分支
删除分支命令：git branch -d (branchname)

分支合并
一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。 你可以使用以下命令将任何分支合并到当前分支中去：
$ git branch
* master
  newtest
$ ls
README        test.txt
$ git merge newtest
Updating 3e92c19..c1501a2
Fast-forward
 runoob.php | 0
 test.txt   | 1 -
 2 files changed, 1 deletion(-)
 create mode 100644 runoob.php
 delete mode 100644 test.txt
$ ls
README        runoob.php
以上实例中我们将newtest分支合并到主分支去，test.txt文件被删除。
合并完后就可以删除分支:
$ git branch -d newtest
Deleted branch newtest (was c1501a2).
删除后， 就只剩下 master 分支了：
$ git branch
* master
##########################################################Git 分支管理##########################################################

##########################################################Git 提交历史##########################################################
Git查看提交历史
在使用Git提交了若干更新之后，又或者克隆了某个项目，想回顾下提交历史，我们可以使用git log命令查看。

git log命令列出历史提交记录。
$ git log

可以用 --oneline选项来查看历史记录的简洁的版本。
$ git log --oneline

还可以用 --graph 选项，查看历史中什么时候出现了分支、合并。以下为相同的命令，开启了拓扑图选项：
$ git log --oneline --graph

也可以用 --reverse 参数来逆向显示所有日志。
$ git log --reverse --oneline

如果只想查找指定用户的提交日志可以使用命令：git log --author,例如，比方说我们要找Git源码中Linus提交的部分：
$ git log --author=Linus --oneline -5

如果你要指定日期，可以执行几个选项：--since和--before，但是你也可以用--until和--after。
例如，如果我要看Git项目中三周前且在四月十八日之后的所有提交，我可以执行这个（我还用了--no-merges选项以隐藏合并提交）： 
$ git log --oneline --before={3.weeks.ago} --after={2010-04-18} --no-merges
 
##########################################################Git 提交历史##########################################################

############################################################Git 标签############################################################
指定标签信息命令：
git tag -a <tagname> -m "runoob.com标签" 
例如：给提交0f315d5追加标签"v1.0"
git tag -a v1.0 -m "追加标签" 0f315d5
执行 git log --decorate 时，我们可以看到我们的标签了： 

检出标签:
git checkout <tagName> -b <branchName>

根据commitid检出代码:
git checkout <commitid> -b <branchName>
注意：如果通过标签或者commitid检出代码不指定branchName的话就会使HEAD处于detached状态（游离状态）。
############################################################Git 标签############################################################

################################################You are in 'detached HEAD' state################################################
什么是 HEAD
Git中的HEAD可以理解为一个指针，我们可以在命令行中输入cat .git/HEAD 查看当前HEAD 指向哪儿，一般它指向当前工作目录所在分支的最新提交。

当使用git checkout < branch_name>切换分支时，HEAD会移动到指定分支。

但是如果使用的是git checkout<commit id>，即切换到指定的某一次提交，HEAD就会处于detached状态（游离状态）

HEAD 游离状态的利与弊
HEAD 处于游离状态时，我们可以很方便地在历史版本之间互相切换，比如需要回到某次提交，直接checkout对应的commit id或者tag名即可。
它的弊端就是：在这个基础上的提交会新开一个匿名分支！
也就是说我们的提交是无法可见保存的，一旦切到别的分支，游离状态以后的提交就不可追溯了（即丢失）。
解决办法就是新建一个分支保存游离状态后的提交。
################################################You are in 'detached HEAD' state################################################