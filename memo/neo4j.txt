cypher：描述性的类sql的图操作语言。（没有join，cypher语言中任何语法都可以有return）

############################################################Create、match、merge############################################################
=====> 创建节点及添加相应的属性
create (grandpa:Person {id:1,name:"王始初",age:68,gender:"male"}) //标签前面的"王始初"是别名，无法通过别名查询，
create (grandma:Person {id:2,name:"郑月娥",age:65,gender:"female"}) 
create (father:Person {id:3,name:"王才仁",age:36,gender:"male"})
create (mother:Person {id:4,name:"赵雅芝",age:32,gender:"female"})
create (Son:Person {id:5,name:"王子",age:25,gender:"male"})
create (daughter:Person {id:6,name:"王燕飞",age:18,gender:"female"})

也可以一次创建：
create (grandpa:Person {id:1,name:"王始初",age:68,gender:"male"}),
       (grandma:Person {id:2,name:"郑月娥",age:65,gender:"female"}), 
       (father:Person {id:3,name:"王才仁",age:36,gender:"male"}),
       (mother:Person {id:4,name:"赵雅芝",age:32,gender:"female"}),
       (son:Person {id:5,name:"王子",age:25,gender:"male"}),
       (daughter:Person {id:6,name:"王燕飞",age:18,gender:"female"})

=====> 创建多个标签的节点 
create (n:Card:Finance {type:"Visa",quota:50000,ValidPeriod:10,conditions:"白领"})

=====> 创建节点之间的关系
match (s:Person {name:"王始初"}), (d:Person {name:"郑月娥"})
create ((s)-[r:wife]->(d))
match (s:Person {name:"郑月娥"}), (d:Person {name:"王始初"})
create ((s)-[r:husband]->(d))

match (s:Person {name:"王才仁"}), (d:Person {name:"赵雅芝"})
create ((s)-[r:wife]->(d))
match (s:Person {name:"赵雅芝"}), (d:Person {name:"王才仁"})
create ((s)-[r:husband]->(d))

match (s:Person {name:"王子"}), (d:Person {name:"王燕飞"})
create ((s)-[r:sister]->(d))
match (s:Person {name:"王燕飞"}), (d:Person {name:"王子"})
create ((s)-[r:brothers]->(d))

match (s:Person {name:"王始初"}), (d:Person {name:"王才仁"})
create ((s)-[r:son]->(d))
match (s:Person {name:"王始初"}), (d:Person {name:"赵雅芝"})
create ((s)-[r:DaughterInLaw]->(d))

match (s:Person {name:"郑月娥"}), (d:Person {name:"王才仁"})
create ((s)-[r:son]->(d))
match (s:Person {name:"郑月娥"}), (d:Person {name:"赵雅芝"})
create ((s)-[r:DaughterInLaw]->(d))

match (s:Person {name:"王才仁"}), (d:Person {name:"王始初"})
create ((s)-[r:father]->(d))
match (s:Person {name:"王才仁"}), (d:Person {name:"郑月娥"})
create ((s)-[r:mother]->(d))

match (s:Person {name:"赵雅芝"}), (d:Person {name:"王始初"})
create ((s)-[r:FatherInLaw]->(d))
match (s:Person {name:"赵雅芝"}), (d:Person {name:"郑月娥"})
create ((s)-[r:MotherInLaw]->(d))

match (s:Person {name:"王才仁"}), (d:Person {name:"王子"})
create ((s)-[r:son]->(d))
match (s:Person {name:"王才仁"}), (d:Person {name:"王燕飞"})
create ((s)-[r:daughter]->(d))

match (s:Person {name:"赵雅芝"}), (d:Person {name:"王子"})
create ((s)-[r:son]->(d))
match (s:Person {name:"赵雅芝"}), (d:Person {name:"王燕飞"})
create ((s)-[r:daughter]->(d))

=====> 在创建节点的同时建立关系，由于在一个会话中，所以后面建立的语句可以使用前面创建节点时用的别名
create (meimei:Person {name:"美眉"}),(gege:Person {name:"哥哥"}),(meimei)-[:husband]->(gege)
如果直接create (meimei)-[:husband]->(gege)的时候将会新建出2个节点和1个关系，并且新创建的节点和关系没有任何属性，只有系统默认分配的id

=====> 通过merge给节点之间添加关系
直接使用merge：如果相同标签及属性的关系不存在，就会新建节点、属性及关系；如果存在的话就相当于查询、检索出相应的节点及属性
merge (m:Person {name:"美眉"})-[r:husband]->(g:Person {name:"哥哥"})
merge (g:Person {name:"哥哥"})-[r:wife]->(m:Person {name:"美眉"}) 

如果想要在原来的节点中修改关系则需要通过match先将符合条件的节点查出来后再merge
match (m:Person {name:"美眉"}) , (g:Person {name:"哥哥"})
merge (g)-[r:wife]->(m)
############################################################Create、match、merge############################################################

#########################################################set、delete、remove#########################################################
=====> 通过set更新节点的属性
match (n:Person {name:"赵雅芝"}) set n.id=4 return n.name,n.id
属性是写数据的时候自动创建，无schema特性，

=====> delete、remove主要区别
delete操作用于删除节点和relation
remove操作用于删除节点中的标签和属性
两个命令都应该与match一起使用

=====> remove属性
先创建：
create (n:Card {type:"万事达",quota:100000,ValidPeriod:10,conditions:"学生"})
更新：
match (n:Card {type:"万事达"}) set n.name='京东联名卡' return n.name
再remove：
match (n:Card {name:"京东联名卡"}) remove n.conditions return n

=====> remove标签（当该标签没有被任何节点引用时，系统会自动删除该标签）
先添加标签：
match (n:Card {name:"京东联名卡"}) set n:Finance return n
再remove标签：
match (n:Card {name:"京东联名卡"}) remove n:Finance

=====> delete关系
先创建节点：
create (a:Teacher {name:"张老师",age:48}),(b:Student {name:"李学生",age:12}),(c:Student {name:"王学生",age:11})
再创建关系：
match (t:Teacher),(l:Student),(w:Student) where t.name="张老师" and w.name="王学生" and l.name="李学生"
merge (t)-[:teach]->(l)
merge (t)-[:teach]->(w)
match (t:Teacher),(l:Student),(w:Student) where t.name="张老师" and w.name="王学生" and l.name="李学生"
merge (l)-[:study]->(t)
merge (w)-[:study]->(t)
删除关系（指定条件：老师姓名、学生姓名）：
match (s:Teacher)-[r:teach]->(d:Student) where s.name="张老师" and d.name="王学生" delete r
删除关系（没有指定条件：将所有的teach关系全部删除掉）：
match (s)-[r:teach]->(d) delete r

注意：如果使用下述语句的话，会将整个库里面存在关系的节点及标签和它们之间的关系全部删除掉（不管这个关系的方向）
match p=()-[]-() delete p
match ()-[r]-() delete r

=====> delete节点
先创建节点：
create (a:Teacher {name:"张老师",age:48}),(b:Student {name:"李学生",age:12}),(c:Student {name:"王学生",age:11})
再删除：
match (n:Teacher) delete n
match (n:Student) delete n
删除所有标签为Teacher的节点，删除从Teacher标签的节点到Student标签的节点的关系中所有的teach关系以及删除所有标签为Student的节点：
match (s:Teacher)-[r:teach]->(d:Student) delete s,r,d
删除所有存在关系的标签为Person的节点以及他们之间的关系（不管这个关系的方向）
match p=(:Person)-[]-(:Person) delete p
match (s:Person)-[r]-(d:Person) delete s,r,d
删除所有标签为Person的节点
match p=(:Person) delete p
match (n:Person) delete n
删除所有关系（不管这个关系的方向）
match p=()-[]-() delete p
match ()-[r]-() delete r
删除所有节点（所有标签的节点）
match p=() delete p
match (n) delete n

注意：如果被删除的节点和其他节点之间还存在关系的话将无法删除

=====> 通过真正的id删除关系和节点
match ()-[r]-() where id(r)=15 delete r
match (n) where id(n)=6 delete n
#########################################################set、delete、remove#########################################################

#########################################################排序、limit、skip#########################################################
=====> order by
match (n:Person) return n order by n.id desc
=====> limit 显示多少行，最前面开始
match (n:Person) return n limit 2
=====> skip：跳过前面的n行
match (n:Person) return n order by n.id desc skip 2
=====> union：（将多段match的return结果组合成一个结果集，自动去重）
match (n:Person) where n.id = 1 return n union match (n:Person) where n.name="王始初" return n
=====> union all
match (n:Person) where n.id = 1 return n union all match (n:Person) where n.name="王始初" return n
=====> is null、is not null
match (n:Person) where n.id is null return n
match (n:Person) where n.id is not null return n
=====> in
match (n:Person) where n.id in [1,3,5] return n
#########################################################排序、limit、skip#########################################################

#########################################################id、index、属性唯一性约束#########################################################
=====> 每个节点或relation都有一个系统分配的id，从0开始递增，全局唯一；可以通过函数id(node/relation)获取id值

=====> Relation具有方向性，Create节点之间关系时，必须指定方向，否则会报错；但是查询的时候可以不指定方向

=====> 索引index
create index on :标签(属性)
drop index on :标签(属性)
1、不需要给索引起名字
2、通过该字段的查询都走索引（即使索引套函数也会走索引）

=====> 执行计划：explain
用法：explain match 语句...

=====> 属性唯一性约束：CONSTRAINT
create constraint on (n:Person) assert n.id is unique
drop constraint on (n:Person) assert n.id is unique
#########################################################id、index、属性唯一性约束#########################################################

###################################################常用函数、shortestPath、allShortestPaths###################################################
=====> 常用函数
功能         描述
toUpper      字母小写转大写 
toLower      字母大写转小写
SUBSTRING    获取子字符串
REPLACE      替换一个字符串的子字符串     

聚集函数     描述
COUNT        返回符合条件的记录数
MAX          返回所有符合条件的字段中的最大值
MIN          返回所有符合条件的字段中的最小值
SUM          返回所有符合条件的字段的和
AVG          返回所有符合条件的字段的平均值

match (n:Person) where n.id > 3 return toUpper(n.gender)
match (n:Person) where n.id > 3 return replace(n.gender,'male','男性')
match (n:Person) where n.id > 3 return avg(n.age)

=====> 二度关系查询
match (s:Person {name:"王子"})-[:father]->()-[:father]->(d) return d.name

=====> shortestPath
MATCH (s:Person { name: '王子' }),(d:Person { name: '王始初' }), p = shortestPath((s)-[*..2]-(d)) RETURN p

=====> allShortestPaths
MATCH (s:Person { name: '王子' }),(d:Person { name: '王始初' }), p = allShortestPaths((s)-[*..2]-(d)) RETURN p

=====> 可变长模式匹配：Variable-length pattern matching
指定长度描述关系，
(a)-[*2]->(b) //描述了一个路径（长度为2的路径）中包含三个节点和两个关系，相当于(a)-->()-->(b)
例：
match p=(s)-[*2]-(d) return p
match (s)-[*2]-(d) return s,d
match p=(s)-->(c)-->(d) return p
match (s)--(c)--(d) return s,c,d
指定长度范围：这种关系模式称为“可变长度”
(a)-[*3..5]->(b) //最小长度为3，最大长度为5：包含了4个节点和3个关系、5个节点和4个关系或6个节点和5个关系的路径
任一个界限都可以省略。
例如，要描述长度为3或更大的路径：
(a)-[*3..]->(b)
描述长度为5或更小的路径：
(a)-[*..5]->(b)
省略两个边界表示任何长度的路径：
(a)-[*]->(b)
描述相邻1个或2个knows关系的路径
(a)-[:knows*1..2]-(b)
###################################################常用函数、shortestPath、allShortestPaths###################################################


​
###############################################From RDBMS to Neo4j, using a classic data set.###############################################

=====> Write Code
:play write-code

=====> Load records
LOAD CSV WITH HEADERS FROM "http://data.neo4j.com/northwind/products.csv" AS row
CREATE (n:Product)
SET n = row,
n.unitPrice = toFloat(row.unitPrice),
n.unitsInStock = toInteger(row.unitsInStock), n.unitsOnOrder = toInteger(row.unitsOnOrder),
n.reorderLevel = toInteger(row.reorderLevel), n.discontinued = (row.discontinued <> "0")

LOAD CSV WITH HEADERS FROM "http://data.neo4j.com/northwind/categories.csv" AS row
CREATE (n:Category)
SET n = row

LOAD CSV WITH HEADERS FROM "http://data.neo4j.com/northwind/suppliers.csv" AS row
CREATE (n:Supplier)
SET n = row

=====> Create indexes
CREATE INDEX ON :Product(productID)
CREATE INDEX ON :Category(categoryID)
CREATE INDEX ON :Supplier(supplierID)

=====> Create data relationships
MATCH (p:Product),(c:Category)
WHERE p.categoryID = c.categoryID
CREATE (p)-[:PART_OF]->(c)

MATCH (p:Product),(s:Supplier)
WHERE p.supplierID = s.supplierID
CREATE (s)-[:SUPPLIES]->(p)

=====> Query using patterns
MATCH (s:Supplier)-->(:Product)-->(c:Category)
RETURN s.companyName as Company, collect(distinct c.categoryName) as Categories
//List the product categories provided by each supplier.
//即对同一companyName里面的categoryName进行去重，而不是对所有的categoryName去重
MATCH (c:Category {categoryName:"Produce"})<--(:Product)<--(s:Supplier)
RETURN DISTINCT s.companyName as ProduceSuppliers
//Find the produce suppliers.
//即categoryName为Produce的商品是由哪些供应商供应的

=====> Load and index records
LOAD CSV WITH HEADERS FROM "http://data.neo4j.com/northwind/customers.csv" AS row
CREATE (n:Customer)
SET n = row

LOAD CSV WITH HEADERS FROM "http://data.neo4j.com/northwind/orders.csv" AS row
CREATE (n:Order)
SET n = row

CREATE INDEX ON :Customer(customerID)

CREATE INDEX ON :Order(orderID)

Load and index records

LOAD CSV WITH HEADERS FROM "http://data.neo4j.com/northwind/customers.csv" AS row
CREATE (n:Customer)
SET n = row

LOAD CSV WITH HEADERS FROM "http://data.neo4j.com/northwind/orders.csv" AS row
CREATE (n:Order)
SET n = row

CREATE INDEX ON :Customer(customerID)

CREATE INDEX ON :Order(orderID)

=====> Create data relationships
MATCH (c:Customer),(o:Order)
WHERE c.customerID = o.customerID
CREATE (c)-[:PURCHASED]->(o)

=====> Load and index records
LOAD CSV WITH HEADERS FROM "http://data.neo4j.com/northwind/order-details.csv" AS row
MATCH (p:Product), (o:Order)
WHERE p.productID = row.productID AND o.orderID = row.orderID
CREATE (o)-[details:ORDERS]->(p)
SET details = row,
details.quantity = toInteger(row.quantity)

=====> Query using patterns
MATCH (cust:Customer)-[:PURCHASED]->(:Order)-[o:ORDERS]->(p:Product),
  (p)-[:PART_OF]->(c:Category {categoryName:"Produce"})
RETURN DISTINCT cust.contactName as CustomerName, SUM(o.quantity) AS TotalProductsPurchased

###############################################From RDBMS to Neo4j, using a classic data set.###############################################