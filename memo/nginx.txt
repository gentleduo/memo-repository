1、创建用户及用户组
//创建系统用户组Nginx 
[root@7Core ~]#groupadd -r nginx 
//创建系统用户nginx并加入nginx系统用户组 
// -r: 添加系统用户 \
// -g: 指定要创建的用户所属组 
// -s: 新帐户的登录shell 
//其中/sbin/nologin指用户不能用来登录系统 
// -d: 新帐户的主目录 
// -M: 不要创建用户的主目录 
//将要被创建的系统用户nginx不会在/home目录下创建nginx家目录 
[root@7Core ~]# useradd -r -g nginx -s /sbin/nologin -d /usr/local/nginx -M nginx

2、创建相关目录
//创建缓存目录在/var/tmp/nginx/ 
[root@7Core ~]# mkdir -pv /var/tmp/nginx/{client_body,proxy,fastcgi,uwsgi,scgi} 
//赋予Nginx用户权限 [root@7Core ~]# 
chown -R nginx:nginx /var/tmp/nginx/ 
//创建日志目录在/usr/local/nginx/ 
[root@7Core ~]# mkdir -pv /usr/local/nginx/logs 
//赋予Nginx用户权限 
[root@7Core ~]# chown -R nginx:nginx /usr/local/nginx/

3、安装基本环境
[root@7Core ~]# yum -y install gcc gcc-c++ autoconf automake make wget vim 
[root@7Core ~]# yum -y install openssl openssl-devel libxml2-devel libxslt-devel perl-devel perl-ExtUtils-Embed libtool zlib zlib-devel pcre pcre-devel patch

4、创建临时软件包目录
root@7Core ~]# mkdir package && cd package

5、安装PCRE-8.42（Nginx的Rewrite功能）
[root@7Core package]# wget https://ftp.pcre.org/pub/pcre/pcre-8.42.tar.gz
[root@7Core package]# tar -zxvf pcre-8.42.tar.gz
[root@7Core package]#cd pcre-8.42/ && ./configure && make && make install && cd ..

6、安装Zlib-1.2.11（Nginx的Gzip压缩功能）
[root@7Core package]# wget http://www.zlib.net/fossils/zlib-1.2.11.tar.gz
[root@7Core package]# tar -zxvf zlib-1.2.11.tar.gz
[root@7Core package]# cd zlib-1.2.11 && ./configure && make && make install && cd ..

7、安装OpenSSL-1.1.1（nginx第三方模块—nginx-sticky-module的使用）
[root@7Core package]# wget https://www.openssl.org/source/openssl-1.1.1-pre8.tar.gz
[root@7Core package]# tar -zxvf openssl-1.1.1-pre8.tar.gz
[root@7Core package]# cd openssl-1.1.1-pre8 && ./config && make && make install && cd ..

8、安装nginx-sticky-module
[root@7Core package]# wget https://bitbucket.org/nginx-goodies/nginx-sticky-module-ng/get/master.tar.gz
[root@7Core package]# tar -zxvf master.tar.gz
[root@7Core package]# mv nginx-goodies-nginx-sticky-module-ng-08a395c66e42/ nginx-sticky-module/

9、安装Nginx-1.15.8
//下载源码包
wget http://nginx.org/download/nginx-1.15.8.tar.gz
//解压源码包
[root@7Core package]# tar -zxvf nginx-1.15.8.tar.gz
//进入工作目录
[root@7Core package]# cd nginx-1.15.8
//安装
./configure \
--prefix=/usr/local/nginx \
--user=nginx \
--group=nginx \
--with-http_ssl_module \
--with-pcre=../pcre-8.42
make
make install
//安装（详细信息）
[root@7Core nginx-1.15.5]# ./configure \
--prefix=/usr/local/nginx \
--sbin-path=/usr/sbin/nginx \
--conf-path=/etc/nginx/nginx.conf \
--error-log-path=/var/log/nginx/error.log \
--http-log-path=/var/log/nginx/access.log \
--pid-path=/var/run/nginx.pid \
--lock-path=/var/lock/nginx.lock \
--user=nginx \
--group=nginx \
--with-http_ssl_module \
--with-http_v2_module \
--with-http_dav_module \
--with-http_flv_module \
--with-http_realip_module \
--with-http_addition_module \
--with-http_xslt_module \
--with-http_stub_status_module \
--with-http_sub_module \
--with-http_random_index_module \
--with-http_degradation_module \
--with-http_secure_link_module \
--with-http_gzip_static_module \
--with-http_perl_module \
--add-module=../nginx-sticky-module \
--with-pcre=../pcre-8.42 \
--with-zlib=../zlib-1.2.11 \
--with-openssl=../openssl-1.1.1-pre8 \
--with-file-aio \
--with-mail \
--with-mail_ssl_module \
--http-client-body-temp-path=/var/tmp/nginx/client_body \
--http-proxy-temp-path=/var/tmp/nginx/proxy \
--http-fastcgi-temp-path=/var/tmp/nginx/fastcgi \
--http-uwsgi-temp-path=/var/tmp/nginx/uwsgi \
--http-scgi-temp-path=/var/tmp/nginx/scgi \
--with-stream \
--with-ld-opt="-Wl,-E"
//编译选项说明
--prefix=PATH //指定nginx的安装目录默认 /usr/local/nginx
--sbin-path=PATH //设置nginx可执行文件的名称。默认/sbin/nginx
--conf-path=PATH //设置nginx.conf配置文件的名称。默认/conf/nginx.conf
--pid-path=PATH //设置存储主进程ID文件nginx.pid的名称。默认/logs/nginx.pid
--error-log-path=PATH //设置错误，警告和诊断文件的名称。默认/logs/error.log
--http-log-path=PATH //置HTTP服务器的请求日志文件的名称。默认/logs/access.log
--lock-path=PATH //安装文件锁定，防止安装文件被利用及误操作
--user=nginx //指定程序运行时的非特权用户。可以随时在nginx.conf配置文件更改。默认为nobody
--group=nginx //指定程序运行时的非特权用户所在组名称。默认设置为非root用户的名称
--with-http_realip_module //启用ngx_http_realip_module支持（允许从请求标头更改客户端的IP地址值，默认关闭）
--with-http_ssl_module //启用ngx_http_ssl_module支持（使支持https请求，需已安装openssl）
--with-http_stub_status_module //启用ngx_http_stub_status_module支持（获取nginx自上次启动以来的工作状态）
--with-http_gzip_static_module //启用ngx_http_gzip_module支持（与without-http_gzip_module功能一致）
--http-client-body-temp-path=PATH //定义http客户端请求临时文件路径
--http-proxy-temp-path=PATH //定义http代理临时文件路径
--http-fastcgi-temp-path=PATH //定义http fastcgi临时文件路径
--http-uwsgi-temp-path=PATH //定义http scgi临时文件路径
--with-pcre //设置pcre库的源码路径，如果已通过yum方式安装，使用–with-pcre自动找到库文件。         //使用--with-pcre=PATH时，需要从PCRE网站下载pcre库的源码（版本8.42）并解压 //剩下的就交给Nginx的./configure和make来完成。 //perl正则表达式使用在location指令和 ngx_http_rewrite_module模块中。
--with-zlib=PATH //指定 zlib-1.2.11的源码目录。默认启用网络传输压缩模块ngx_http_gzip_module时需要使用zlib
--with-http_ssl_module //使用https协议模块。默认情况下，该模块没有被构建。前提是openssl已安装
--add-module=PATH //添加第三方外部模块，如nginx-sticky-module-ng或缓存模块。每次添加新的模块都要重新编译

// 建立链接
ln -s /usr/local/nginx/sbin/nginx /usr/local/sbin/nginx

nginx                      # 启动Nginx
nginx -s reload            # 在nginx已经启动的情况下重新载入配置文件（平滑重启）
nginx -s reopen            # 重新打开日志文件
nginx -s stop              # 停止 Nginx
nginx -s quit              # stop的方式是立即停止Nginx服务，无论当前工作进程是否正在处理工作。而quit是在完成当前工作任务后再停止
nginx -c /xxx/nginx.conf   # 以特定目录下的配置文件启动Nginx
nginx -t                   # 检测当前配置文件是否正确
nginx -t -c /xxxx/nginx.conf  #检测特定目录下的Nginx配置文件是否正确
nginx -v                   # 显示版本信息
nginx -V                   # 显示版本信息和编译选项

############################################################nginx-root,alias,index############################################################
1. root
root模块就是用来指定访问资源的document_root，nginx会将root的值和location的值进行拼接，然后再拼接上url剩余的部分及index指定的值，举例：
location /a/{
    root    /usr/local;
    index   1.html;
}
访问结果如下：
/a/  --> /usr/local/a/1.html
/a/b --> /usr/local/a/b/1.html
如果在location中不加index，只需要在请求的URI中指定好资源，也可访问成功，举例：
location /a/{
    root    /usr/local;
}
访问结果如下：
/a/1.html   --> /usr/local/a/1.html
/a/b/1.html --> /usr/local/a/b/1.html
2. alias
alias模块也是用来指定访问资源的document_root，但是nginx会将alias的值替换location的值，然后再拼接上url剩余的部分及index指定的值，举例：
location /a/{
    alias    /usr/local/;
    index    1.html;
}
访问结果如下：
/a --> /usr/local/1.html
/a/b --> /usr/local/b/1.html
alias模块有点需要注意：
alias指定的是document_root，不能直接指定到具体的文件，否则会500，例如：
location /a/{
    alias    /usr/local/1.html;
    #index    1.html;
}
这种配置会让nginx报出500
使用alias时，目录后面一定要加"/"。（root目录配置中，location匹配的path目录后面带不带"/"，都不会影响访问。）
alias只能位于location块中。（root可以不放在location中）
3. index
通过上面的两个例子，我们知道index就是用来指定具体的资源的名字的，index可以指定多个资源的名字，第一个匹配不到，就会匹配第二个，直到匹配到为止。
但是location使用严格匹配的时候，不能使用index，否则会导致root失效，如：
location =/a/{
    root    /usr/local/;
    index    1.html;
}
当访问的url为/a/时，实际访问的资源为：nginx的默认document_root/a/1.html，使得root失效，值得注意的是nginx的默认document_root和我们root指定的是不一样的，所以最后会404
############################################################nginx-root,alias,index############################################################

##################################################################server_name#################################################################
客户端通过域名访问服务器时会将域名与被解析的ip一同放在请求中。当请求到了nginx中时。nginx会先去匹配ip，如果listen中没有找到对应的ip，就会通过域名进行匹配，匹配成功以后，再匹配端口。当这三步完成，就会找到对应的server的location对应的资源。

第一步：在客户端配置hosts（C:\Windows\System32\drivers\etc\hosts）
192.168.56.201 www.test201.com
192.168.56.202 www.test202.com
192.168.56.203 www.test203.com
第二步：给虚拟机（服务端）配置另外三个ip
ifconfig enp0s8:1 192.168.56.201/24 up
ifconfig enp0s8:2 192.168.56.202/24 up
ifconfig enp0s8:3 192.168.56.203/24 up
再次执行：ifconfig、可以看到多了三个ip
第三步：建立相关的nginx的文件
1.建立虚拟主机存放网页的根目录，并创建首页文件index.html
mkdir -p /opt/app/www
cd /opt/app/www
mkdir 201
mkdir 202
mkdir 203
echo "192.168.56.201" > 201/index.html; echo "192.168.56.202" > 202/index.html;echo "192.168.56.203" > 203/index.html
2.修改nginx.conf，将虚拟主机配置文件包含进主文件
    #通过ip配置
    server {
            listen       192.168.56.201:80;
            #server_name  www.test201.com;

            access_log   /opt/app/www/logs/www.test201.com.log main;
            error_log    /opt/app/www/logs/www.test201.com.error.log;

            location / {
                root   /opt/app/www/201;
                index  index.html index.htm;
            }
    }
    server {
            listen       192.168.56.202:80;
            #server_name  www.test202.com;

            access_log   /opt/app/www/logs/www.test202.com.log main;
            error_log    /opt/app/www/logs/www.test202.com.error.log;

            location / {
                root   /opt/app/www/202;
                index  index.html index.htm;
            }
    }
    server {
            listen       192.168.56.203:80;
            #server_name  www.test203.com;

            access_log   /opt/app/www/logs/www.test203.com.log main;
            error_log    /opt/app/www/logs/www.test203.com.error.log;

            location / {
                root   /opt/app/www/203;
                index  index.html index.htm;
            }
    }
可以使用ip和域名访问。
3.把server中的ip都删除，把server_name的注释都解开。重启nginx。在访问，发现用域名能访问到对应的资源。
使用ip就只会出现192.168.56.201的资源
这是因为通过其他ip也能请求到nginx，但是匹配不到相应的server，这个时候就会使用第一个server。
4.将server_name=www.test203.com的server的listen加上ip 192.168.56.202:80,重启nginx。
这个时候使用www.test202.com，或者192.168.56.202进行访问就可以得到server_name= www.test203.com的资源。
但是使用www.test203.com访问的到的是192.168.56.201的资源。这是因为：如果server中配置了ip，那么我们就使用客户端带来的ip进行匹配，这个时候server_name失效。

##################################################################server_name#################################################################


//location、proxy_pass、upstream与resolver
#############################################nginx配置中location匹配规则详解#############################################
1、 location 的匹配顺序其实是“先匹配普通，再匹配正则”。
2、“普通location”的匹配规则是“最大前缀”，因此“普通location”的确与location编辑顺序无关；但是“正则location”的匹配规则是“顺序匹配，且只要匹配到第一个就停止后面的匹配”；“普通location”与“正则location”之间的匹配顺序是？先匹配普通location，再“考虑”匹配正则location。注意这里的“考虑”是“可能”的意思，也就是说匹配完“普通location”后，有的时候需要继续匹配“正则location”，有的时候则不需要继续匹配“正则location”。两种情况下，不需要继续匹配正则location：（1）当普通location前面指定了“^~”，特别告诉Nginx本条普通location一旦匹配上，则不需要继续正则匹配；（2）当普通location恰好严格匹配上，不是最大前缀匹配，则不再继续匹配正则。

location
syntax: location [=|~|~*|^~|@] /uri/ { … }
1 、different configurations depending on the URI 说的就是语法格式：location [=|~|~*|^~|@] /uri/ { … } ，依据不同的前缀“= ”，“^~ ”，“~ ”，“~* ”和不带任何前缀的（因为[A] 表示可选，可以不要的），表达不同的含义, 简单的说尽 管location 的/uri/ 配置一样，但前缀不一样，表达的是不同的指令含义。
2 、查询字符串不在URI范围内。例如： /films.htm?fid=123 的URI 是/films.htm 。

location /uri/ 可通过使用不同的前缀，表达不同的含义。对这些不同前缀，分2大类：
正则location ，英文说法是location using regular expressions “~”和“~*”前缀表示正则location(“~”区分大小写，“~*”不区分大小写)
普通location ，其他前缀（包 括：“=”，“^~”和“@”）和无任何前缀的都属于普通location 。

对于一个特定的HTTP请求（aparticularquery），nginx应该匹配哪个location块的指令呢（注意：我们在nginx.conf配置文件里面一般会定义多个location的）？匹配规则是：先匹配普通location（再匹配正则表达式）。
“普通location”内部（普通location与普通location）是如何匹配的呢？简单的说：最大前缀匹配。
1、match the beginning portion of the query（说的是匹配URI 的前缀部分beginning portion）； 
2、the most specific match will be used 
（因为location不是“严格匹配”，而是“前缀匹配”，就会产生一个HTTP请求，可以“前缀匹配”到多个普通location，例如：location /prefix/mid/{}和location /prefix/{}，对于HTTP请求/prefix/mid/t.html，前缀匹配的话两个location都满足，选哪个？原则是：the most specific match，于是选的是location /prefix/mid/{}）。

普通location先匹配，而且选择了最大前缀匹配后，不能就停止后面的匹配，最大前缀匹配只是一个临时的结果，nginx 还需要继续检查正则location（但至于最终使用普通location的最大前缀匹配，还是正则location的匹配，截止 当前的内容还没讲，但后面会讲）。
“正则location”内部的匹配规则是：按照正则location在配置文件中的物理顺序（编辑顺序）匹配的（这句话就说明location 并不是一定跟顺序无关，只是普通location与顺序无关，正则location还是与顺序有关的），并且只要匹配到一条正则location ，就不再考虑后面的（这与“普通location”与“正则location”之间的规则不一样，“普通location”与“正则location ”之间的规则是：选择出“普通location”的最大前缀匹配结果后，还需要继续搜索正则location）。

匹配结果的决策关系。如果继续搜索的“正则location”也有匹配上的，那么“正则location”覆盖“普通location”的最大前缀匹配；但是如果“正则location”没有能匹配上，那么就用“普通location”的最大前缀匹配结果。

通常的规则是，匹配完了“普通location”指令，还需要继续匹配“正则location”，但是你也可以告诉Nginx：匹配到了“普通location”后，不再需要继续匹配“正则location”了，要做到这一点只要在“普通location”前面加上“^~”符号（^表示“非”，~表示“正则”，字符意思是：不要继续匹配正则）。
除了“^~”可以阻止继续搜索正则location外，你还可以加“=”。那么如果“^~”和“=”都能阻止继续搜索正则location的话，那它们之间有什么区别呢？区别很简单，共同点是它们都能阻止继续搜索正则location，不同点是“^~”依然遵守“最大前缀”匹配规则，然而“=”不是“最大前缀”，而是必须是严格匹配（exact match）

这里顺便讲下“location / {}”和“location = / {}”的区别，“location / {}”遵守普通location的最大前缀匹配，由于任何URI都必然以“/ ”根开头，所以对于一个URI，如果有更specific的匹配，那自然是选这个更specific的，如果没有，“/”一定能为这个URI垫背（至少能匹配到“/”），也就是说“location/{}”有点默认配置的味道，其他更specific的配置能覆盖overwrite这个默认配置（这也是为什么我们总能看到location / {}这个配置的一个很重要的原因）。而“location = / {}”遵守的是“严格精确匹配exact  match”，也就是只能匹配http://host:port/请求，同时会禁止继续搜索正则location。因此如果我们只想对“GET /”请求配置作用指令，那么我们可以选“location = / {}”这样能减少正则location的搜索，因此效率比“location / {}” 高（注：前提是我们的目的仅仅只想对“GET /”起作用）。

普通location匹配完后，还会继续匹配正则location；但是nginx允许你阻止这种行为，方法很简单，只需要在普通location前加“^~”或“=”。

实验证明：下面的说法不正确（实际情况是只有为严格精确匹配的时候才会阻止正则搜索，其他的情况都会进行后面的正则搜索）
但其实还有一种“隐含”的方式来阻止正则location的搜索，这种隐含的方式就是：当“最大前缀”匹配恰好就是一个“严格精确（exact match）”匹配，照样会停止后面的搜索。原文字面意思是：只要遇到“精确匹配exact match”，即使普通location没有带“=”或“^~”前缀，也一样会终止后面的匹配。

案例
假设，现有如下一些规则：
location = / {  
    #//精确匹配/ ，主机名后面不能带任何字符串
	default_type text/html;
	return 200 "number A";
}
 
location = /login {
	#精确匹配 /login 开头的地址，匹配符合以后，不在继续往下搜索
	default_type text/html;
	return 200 "number B";
}
 
location ^~ /blog/ { 
	#非正则匹配，匹配/blog/后，停止往下搜索正则，采用这一条
	default_type text/html;
	return 200 "number C";
}
 
 
location ~  \.(gif|jpg|png|js|css)$ {
	#区分大小写的正则匹配  若匹配成功，停止往下搜索正则，采用这一条
	default_type text/html;
	add_header  Content-Type 'text/html; charset=utf-8';
	return 200 "number D";
}
 
 
location ~* \.png$ {  
	#区分大小写的正则匹配 ，停止往下搜索正则，采用这一条
	default_type text/html;
	#如果不设置Content-Type的话，则response中的Content-Type会因为被设置成为了imamge/png而显示不正常，
	add_header  Content-Type 'text/html; charset=utf-8';
	return 200 "number E";
}
 
location / {
	#因为所有的地址都以 / 开头，所以这条规则将匹配到所有请求
	#如果没任何规则匹配上，就采用这条规则
	default_type text/html;
	return 200 "number F";
}
 
location /blog/detail { 
	#最长字符串匹配，若完全匹配成功，就不在继续匹配，否则还会进行正则匹配
	default_type text/html;
	return 200 "number G";
}
 
location /images {  
	#最长字符串匹配，同上
	default_type text/html;
	return 200 "number Y";
}
 
location ^~ /static/files {  
	#非正则匹配，若匹配成功，就不在继续匹配
	default_type text/html;
	return 200 "number X";
}
1、当访问根路径/的时候，比如http://www.findme.wang/ ，会匹配规则A。
2、当访如http://www.findme.wang/login ，会匹配规则B。
3、当访如http://www.findme.wang/login.html ，会匹配规则F。
4、当访如http://www.findme.wang/blog/detail/3.html，会匹配规则G。分析思路，首先看看，“精确匹配”是否可以匹配成功，显示不可以；然后，看看是否可以“普通匹配”是否可以完全匹配，显示也没有；接着再看“普通匹配”的最大前缀匹配发现有两条规则符合要求C和G，根据themostspecificmatch原则，先将规则G作为临时结果保存，（由于规则G没有加“^~”符号所以还要继续检查正则location。如果注释掉规则G的location，因为规则C的location加了“^~”符号所以在匹配到普通location后不再需要继续匹配“正则location”了，所以这个时候返回的是规则C）然后继续检查正则location，在正则location中没有匹配到，所以返回G。

nginx配置文件通过使用add_header指令来设置response header。
具体方法如下：
add_header key value
add_header Cache-Control no-store
add_header Content-Encoding gzip
用以改变Content-Type时比较特殊，可以在它设置了类型的同时还会指定charset，不过Content-Type和charset之间有分号，所以我们需要这样来添加。
add_header  Content-Type 'text/html; charset=utf-8';
这样就可以给responent header的Content-Type添加指定的属性了。
匹配所有.js文件的话，设置responent header的Content-Type值赋值为"text/javascript;charset=utf-8"。

#############################################nginx配置中location匹配规则详解#############################################

#############################################nginx配置中proxy_pass匹配规则详解#############################################
在nginx中配置proxy_pass代理转发时，如果在proxy_pass后面的url加/，表示绝对根路径；如果没有/，表示相对路径，把匹配的路径部分也给代理走。
假设下面两种种情况分别用 http://server02/app/api001进行访问：（proxy_pass不包含URI）
第一种：
location /app/ {
    proxy_pass http://server01:8085/;
}
代理到URL：http://server01:8085/api001
第二种（相对于第一种，最后少一个/）
location /app/ {
    proxy_pass http://server01:8085;
}
代理到URL：http://server01:8085/app/api001

反向代理proxy_pass的语法结构为proxy_pass URL，其中，URL为要设置的被代理服务器的地址，包含传输协议、主机名称或IP地址加端口号、URI等要素。
proxy_pass URL ,URL中是否含有URI，如果不包含，nginx服务器不会改变原地址的URI；如果包含了URI，则nginx服务器会使用新的URI替换原来的URI。
（nginx服务器会使用新的URI然后再拼接上和location匹配之后剩余的部分组成新的URL）
假设下面两种种情况分别用http://server02:81/proxy/api001进行访问：（proxy_pass包含URI）
第一种：
location /proxy/ {
    proxy_pass http://server01:8085/app;
}
代理到URL：http://server01:8085/appapi001
第二种（相对于第一种，最后少一个/）
location /proxy/ {
    proxy_pass http://server01:8085/app/;
}
代理到URL：http://server01:8085/app/api001
#############################################nginx配置中proxy_pass匹配规则详解#############################################

##########################################################nginx配置中Rewrite用法总结##########################################################
1.rewrite的定义
rewrite功能就是使用nginx提供的全局变量或自己设置的变量，结合正则表达式和标志位实现url重写以及重定向
rewrite只能放在 server{}, location{}, if{}中，并且只能对域名后边的除去传递的参数外的字符串起作用。
例如 http://seanlook.com/a/we/index.php?id=1&u=str 只对/a/we/index.php重写。
2.rewirte的语法
rewrite regex replacement [flag];
如果相对域名或参数字符串起作用，可以使用全局变量匹配，也可以使用proxy_pass反向代理。 rewrite和location功能看似有点像，都能实现跳转。主要区别在于rewrite是在同一域名内更改获取资源的路径，而location是对一类路径做控制访问或反向代理，可以proxy_pass到其他机器。
很多情况下rewrite也会写在location里，它们的执行顺序是：
1 执行server块的rewrite指令
2 执行location匹配
3 执行选定的location中的rewrite指令
如果其中某步URI被重写，则重新循环执行1-3，直到找到真实存在的文件；循环超过10次，则返回500 Internal Server Error错误。
flag标志位
    last : 相当于Apache的[L]标记，表示完成rewrite
    break : 停止执行当前虚拟主机的后续rewrite指令集
    redirect : 返回302临时重定向，地址栏会显示跳转后的地址
    permanent : 返回301永久重定向，地址栏会显示跳转后的地址
因为301和302不能简单的只返回状态码，还必须有重定向的URL，这就是return指令无法返回301,302的原因了。这里last和break区别有点难以理解：
    last一般写在server和if中，而break一般使用在location中
    last不终止重写后的url匹配，即新的url会再从server走一遍匹配流程，而break终止重写后的匹配
    break和last都能阻止继续执行后面的rewrite指令
rewrite在if中的用法
格式：if (条件判断) { 具体的rewrite规则 }
if条件判断语句由Nginx内置变量、逻辑判断符号和目标字符串三部分组成。
其中，内置变量是Nginx固定的非自定义的变量，如，$request_method, $request_uri等。
逻辑判断符号，有=, !=, ~, ~*, !~, !~*
!表示相反的意思，~为匹配符号，它右侧为正则表达式，区分大小写，而~*为不区分大小写匹配。
目标字符串可以是正则表达式，通常不用加引号，但表达式中有特殊符号时，比如空格、花括号、分号等，需要用单引号引起来。
示例1：当http请求方法为post时，返回403状态码
if ($request_method = POST)
{
    return 403; 
}
示例2：通过浏览器标识匹配关键字，禁止IE浏览器访问
if ($http_user_agent ~* MSIE) 
{
    return 403;
}
限制多个浏览器：
if ($http_user_agent ~* "MSIE|firefox|Chrome")
{
    return 403;
}
示例3：当请求的文件不存在时，进行重定向或return状态码等处理操作
if(!-f $request_filename)
{
    rewrite 语句;
}
示例4：判断uri中某个参数的内容
if($request_uri ~* 'gid=\d{6,8}/') 
{
    rewrite 语句;
}
#\d表示数字，{6,8}表示数字出现的次数是6到8次，当uri中gid参数的值包含6-8个数字那么执行rewrite语句

rewrite中break和last的用法
两个指令用法相同，但含义不同，需要放到rewrite规则的末尾，用来控制重写后的链接是否继续被nginx配置执行(主要是rewrite、return指令)。
1.break和last在location{}外部时
测试示例：
server{
    listen 80; 
    server_name test.com;
    root /data/wwwroot/test.com;

    rewrite /1.html /2.html;
    rewrite /2.html /3.html;
}
#请求1.html文件时，会被重定向到2.html，然后被重定向到3.html，最后返回的文件为3.html
示例1：在rewrite 指令后面添加break
server{
    listen 80; 
    server_name test.com;
    root /data/wwwroot/test.com;

    rewrite /1.html /2.html break;
    rewrite /2.html /3.html;
}
#请求1.html文件时，会被重定向到2.html，然后直接返回2.html，break在此处的作用就是当匹配第一个rewrite指令成功时，不执行后面的rewrite指令
示例2：当break后面还有location{}的情况
server{
    listen 80; 
    server_name test.com;
    root /data/wwwroot/test.com;

    rewrite /1.html /2.html break;
    rewrite /2.html /3.html;
    location /2.html {
        return 403;
    }
}
#请求1.html文件时，会返回403状态码，这是因为当1.html被重定向到2.html时，break不会匹配后面的rewrite规则，但条件2.html匹配location{}定义的文件2.html，所以会执行return 403
#以上两个示例中，将break换成last效果一样

2.break和last在location{}内部时
测试示例：
server{
    listen 80; 
    server_name test.com;
    root /data/wwwroot/test.com;
    
    location / {
        rewrite /1.html /2.html;
        rewrite /2.html /3.html;
    }
    location /2.html
    {
        rewrite /2.html /a.html;
    }
    location /3.html
    {
        rewrite /3.html /b.html;
    }
}
#请求1.html，会经过两次重定向到3.html，3.html又刚好匹配location /3.html{}，所以返回b.html，当请求2.html时，会直接返回a.html，因为location /2.html {} 更精准，优先匹配
示例1：在rewrite后面添加break
server{
    listen 80; 
    server_name test.com;
    root /data/wwwroot/test.com;
    
    location / {
        rewrite /1.html /2.html break;
        rewrite /2.html /3.html;
    }
    location /2.html
    {
        rewrite /2.html /a.html;
    }
    location /3.html
    {
        rewrite /3.html /b.html;
    }
}
#请求1.html，会返回2.html，不会返回a.html，当break再location {} 内部时，遇到break后，当前location{} 以及后面的location{} 的指令都不再执行
示例2：在rewrite后面添加last
server{
    listen 80; 
    server_name test.com;
    root /data/wwwroot/test.com;
    
    location / {
        rewrite /1.html /2.html last;
        rewrite /2.html /3.html;
    }
    location /2.html
    {
        rewrite /2.html /a.html;
    }
    location /3.html
    {
        rewrite /3.html /b.html;
    }
}
#请求1.html时，会返回a.html，在location {} 内部遇到last，当前location {}中剩下的指令不会再执行，但被重定向的url会重新匹配一遍location {}
3.break和last用法总结
1.当rewrite规则在location{}外，break和last作用一样，遇到break或last后，其后续的rewrite/return语句不再执行。但后续有location{}的话，还会近一步执行location{}里面的语句,前提是请求能匹配该location
2.当rewrite规则在location{}里，遇到break后，本location{}与其他location{}的所有rewrite/return规则都不再执行
3.当rewrite规则在location{}里，遇到last后，本location{}里后续rewrite/return规则不执行，但重写后的url再次从头匹配所有location

return的用法
该指令一般用于对请求的客户端直接返回响应状态码。在该作用域内return后面的所有nginx配置都是无效的，可以使用在server、location以及if配置中，除了支持跟状态码，还可以跟字符串或者url链接。
示例1：直接返回状态码
server{
    listen 80;
    server_name www.test.com;
    return 403;
    rewrite www.test.net;  
}
#访问时，直接返回403状态码，return返回内容后，后面的配置rewrite不会执行
示例2：当return在if 判断中时
server {
.....

if ($request_uri ~ "\.password|\.bak")
{
    return 404;
    rewrite /(.*) /index.html;  
}
.....
}
#请求的文件包含.password或.bak时，直接返回404，rewrite不会执行，但if {}外的配置会继续执行，return只在当前作用域中生效
示例3：返回字符串
server{
    listen 80;
    server_name www.test.com;
    return 200 "hello";
}
#返回字符串必须加上状态码，否则会报错
示例4：返回nginx变量
location /1.html {
    return 200 "$host $request_uri";
}
示例5：返回url
server{
    listen 80;
    server_name www.test.com;
    return http://www.test.com/index2.html;
}
#返回url时，必须以http://或https://开头
示例6：返回html代码
if ($http_referer ~ 'baidu.com') 
{
    return 200 "<html><script>window.location.href='//$host$request_uri';</script></html>";
}
#当网站被黑了的时候，从百度点进网站是链接都会跳转到其他网站，可以使用该方法暂时处理
#注意：return http://$host$request_uri; 在浏览器中会提示"重定向的次数过多"

rewrite应用实例
1.域名跳转（域名重定向）
单个域名的情况：
server{
    listen 80;
    server_name www.test.com;
    rewrite /(.*) http://www.test.net/$1 permanent;    
}
多个域名的情况：
server{
    listen 80;
    server_name www.test.com www.test.net;
    if ($host != 'www.test.net')
    {
        rewrite /(.*) http://www.test.net/$1 permanent;
    }
}
2.http跳转https
server{
    listen 80;
    server_name www.test.com;
    rewrite /(.*) https://www.test.com/$1 permanent;
}
3.跳转二级目录
server{
    listen 80;
    server_name bbs.test.com;
    rewrite /(.*) http://www.test.com/bbs/$1 last;
}
4.动静态请求分离
server{
    listen 80;
    server_name www.test.com;
    location ~* .*\.(jpg|jpeg|gif|css|png|js)$
    {
        rewrite /(.*) http://img.test.com/$1 permanent;
    }
}
#假设www.test.com的服务器在国外，访问速度较慢，img.test.com的服务器在国内，访问速度正常，可以将访问www.test.com静态文件的请求重定向到img.test.com，提高文件返回速度
##########################################################nginx配置中Rewrite用法总结##########################################################

#############################################详解proxy_pass、upstream与resolver#############################################
列举几个应用场景，针对这几个场景并结合代码进行分析。
1、proxy_pass + upstream
upstream foo.example.com {
	server 127.0.0.1:8001;
}

server {
	listen       80;
	server_name  localhost;

	location /foo {
		proxy_pass http://foo.example.com;
	}
}
访问http://localhost/foo，proxy模块会将请求转发到127.0.0.1的8001端口上。

2、只有proxy_pass，没有upstream与resolver
server {
	listen       80;
	server_name  localhost;

	location /foo {
		proxy_pass http://foo.example.com;
	}
}
实际上是隐式创建了upstream，upstream名字就是foo.example.com。upstream模块利用本机设置的DNS服务器（或/etc/hosts），将foo.example.com解析成IP，访问http://localhost/foo，proxy模块会将请求转发到解析后的IP上。
如果本机未设置DNS服务器，或者DNS服务器无法解析域名，则nginx启动时会报类似如下错误：
nginx: [emerg] host not found in upstream "foo.example.com" in /path/nginx/conf/nginx.conf:110

3、proxy_pass + resolver（变量设置域名）
server {
	listen       80;
	server_name  localhost;

	resolver 114.114.114.114;
	location /foo {
		set $foo foo.example.com;
		proxy_pass http://$foo;
	}
}
访问http://localhost/foo，nginx会动态利用resolver设置的DNS服务器（本机设置的DNS服务器或/etc/hosts无效），将域名解析成IP，proxy模块会将请求转发到解析后的IP上。

4、proxy_pass + upstream（显式） + resolver（变量设置域名）
upstream foo.example.com {
	server 127.0.0.1:8001;
}

server {
	listen       80;
	server_name  localhost;

	resolver 114.114.114.114;
	location /foo {
		set $foo foo.example.com;
		proxy_pass http://$foo;
	}
}
访问http://localhost/foo时，upstream模块会优先查找是否有定义upstream后端服务器，如果有定义则直接利用，不再走DNS解析。所以proxy模块会将请求转发到127.0.0.1的8001端口上。

5、proxy_pass + upstream（隐式） + resolver（变量设置域名）
server {
	listen       80;
	server_name  localhost;

	resolver 114.114.114.114;
	location /foo {
		set $foo foo.example.com;
		proxy_pass http://$foo;
	}

	location /foo2 {
		proxy_pass http://foo.example.com;
	}
}
location /foo2实际上是隐式定义了upstream foo.example.com，并由本地DNS服务器进行了域名解析，访问http://localhost/foo时，upstream模块会优先查找upstream，即隐式定义的foo.example.com，nginx再动态利用resolver设置的DNS服务器（本机设置的DNS服务器或/etc/hosts无效），将域名（foo.example.com）解析成IP，proxy模块会将请求转发到解析后的IP上。

6、proxy_pass + resolver（不用变量设置域名）
server {
	listen       80;
	server_name  localhost;

	resolver 114.114.114.114;
	location /foo {
		proxy_pass http://foo.example.com;
	}
}
不使用变量设置域名，则resolver的设置不起作用，此时相当于场景2，只有proxy_pass的场景。

7、proxy_pass + upstream + resolver（不用变量设置域名）
upstream foo.example.com {
	server 127.0.0.1:8001;
}

server {
	listen       80;
	server_name  localhost;

	resolver 114.114.114.114;
	location /foo {
		proxy_pass http://foo.example.com;
	}
}
不使用变量设置域名，则resolver的设置不起作用，此时相当于场景1 proxy_pass + upstream。

8、proxy_pass 直接指定IP加端口号
server {
	listen       80;
	server_name  localhost;

	location /foo {
		proxy_pass http://127.0.0.1:8001/;
	}
}
实际上是隐式创建了upstream，proxy_pass会将请求转发到127.0.0.1的8001端口上。

正向代理主要使用proxy_pass、resolver实现，例如：
Nginx配置如下：
server {
    # 配置DNS解析IP地址，比如 Google Public DNS，以及超时时间（5秒）
	# resolver 114.114.114.114 8.8.8.8;
	resolver x.x.x.x;# 必需
	resolver_timeout 5s;
	listen 82;
	access_log  /home/reistlin/logs/proxy.access.log;
    error_log   /home/reistlin/logs/proxy.error.log;
	location / {
        # 配置正向代理参数
        proxy_pass $scheme://$host$request_uri;
        # 解决如果URL中带"."后Nginx 503错误
        proxy_set_header Host $http_host;
        # 配置缓存大小
        proxy_buffers 256 4k;
        # 关闭磁盘缓存读写减少I/O
        proxy_max_temp_file_size 0;
         # 代理连接超时时间
        proxy_connect_timeout 30;
        # 配置代理服务器HTTP状态缓存时间
        proxy_cache_valid 200 302 10m;
        proxy_cache_valid 301 1h;
        proxy_cache_valid any 1m;
	}
}
注意项：
1. 不能有hostname
2. 必须有resolver, 即dns，即上面的x.x.x.x，换成你们的DNS服务器ip即可
3 . $http_host和$request_uri是nginx系统变量，不要替换他们，保持原样。
查看dns方法 cat /etc/resolv.conf 代理使用
在需要访问外网的机器上执行以下操作之一即可：
一次代理，直接在shell执行：
1. export http_proxy=http://yourproxyaddress：proxyport
永久使用：
2. gedit ~/.bashrc export http_proxy=http://yourproxyaddress：proxyport
yourproxyaddress也就是你的Nginx服务器的ip了，proxyport就是上面配置中的82，可以根据自己的需要修改

反向代理：主要使用proxy_pass、upstream实现，upstream配置比较简单，但是如果做负载均衡和优化，还是需要下一番功夫的。
#############################################详解proxy_pass、upstream与resolver#############################################

#############################################fail_timeout和max_fails#############################################
   upstream  netitcast.com {  #服务器集群名字
        ip_hash;
        server 127.0.0.1:18080 max_fails=3 fail_timeout=30s;
        server 127.0.0.1:28080 max_fails=3 fail_timeout=30s;
    }
    

    server {
        listen       80;
        server_name  localhost;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / {
            proxy_pass http://netitcast.com/;  
            proxy_buffering off;
            proxy_redirect default;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_connect_timeout 3;
        }
	}

max_fails=3，fail_timeout=30s代表在30秒内请求某一应用失败3次，认为该应用宕机，后等待30秒，这期间内不会再把新请求发送到宕机应用，而是直接发到正常的那一台，时间到后再有请求进来继续尝试连接宕机应用且仅尝试1次，如果还是失败，则继续等待30秒...以此循环，直到恢复。
Nginx的负载均衡检查模块的特点：
1)Nginx只有当有访问时后，才发起对后端节点探测
2)两个节点都可用的情况下，突然有一个节点挂掉，客户端请求过来后哪怕刚好轮询到了不可用的节点，此次请求也不会失败，因为Nginx会把此次请求转发到另外一个可用节点，再把结果返回给客户端。
#############################################fail_timeout和max_fails#############################################

#############################################yum install nginx#############################################
环境调试确认：
两项安装
yum -y install gcc gcc-c++ autoconf pcre pcre-devel make automake
yum -y install wget httpd-tools vim

安装方法见官网：
http://nginx.org/en/linux_packages.html
1 配置nginx的yum源仓库：
创建/etc/yum.repos.d/nginx.repo，内容如下：
[nginx-stable]
name=nginx stable repo
baseurl=http://nginx.org/packages/centos/$releasever/$basearch/
gpgcheck=1
enabled=1
gpgkey=https://nginx.org/keys/nginx_signing.key
module_hotfixes=true
根据所使用的分配，将"OS"替换为"centos"，对于5.x，6.x或7.x，请将"OSRELEASE"替换为"5"，"6"或"7" 版本，
例如：系统是centos7,所以上面的baseurl就是：baseurl=http://nginx.org/packages/centos/7/$basearch/
注意：$basearch这个就是一个变量，不需要替换。
Mainline version - 开发版本
Stable version - 稳定版
Legacy version - 历史版

yum安装下的nginx，如何添加模块，和添加第三方模块
1、查看nginx版本模块
nginx -V
2、下载一个同版本的可编译的nginx
cd /home/ngadm
wget http://nginx.org/download/nginx-1.16.1.tar.gz
tar zxvf nginx-1.12.2.tar.gz && cd nginx-1.16.1
3、备份、备份、备份
备份文件
mv /usr/sbin/nginx /usr/sbin/nginx_BAK
cp -r /etc/nginx /etc/nginx_BAK
4、检查模块是否支持，比如这次添加limit限流模块 和stream模块：
./configure –-help | grep limit
注：--without-http_limit_conn_module disable 表示已有该模块，编译时，不需要添加
./configure –-help | grep stream
注：–-with-stream enable 表示不支持，编译时要自己添加该模块
根据第一步查到已有的模块，加上本次需新增的模块，那么最终结果如下：（例本次追加ngx_http_proxy_connect_module模块）
./configure --prefix=/etc/nginx --sbin-path=/usr/sbin/nginx --modules-path=/usr/lib64/nginx/modules --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/run/nginx.pid --lock-path=/var/run/nginx.lock --http-client-body-temp-path=/var/cache/nginx/client_temp --http-proxy-temp-path=/var/cache/nginx/proxy_temp --http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp --http-scgi-temp-path=/var/cache/nginx/scgi_temp --user=nginx --group=nginx --with-compat --with-file-aio --with-threads --with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-mail --with-mail_ssl_module --with-stream --with-stream_realip_module --with-stream_ssl_module --with-stream_ssl_preread_module --with-cc-opt='-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector --param=ssp-buffer-size=4 -m64 -mtune=generic -fPIC' --with-ld-opt='-Wl,-z,relro -Wl,-z,now -pie' --add-module=/opt/ngx_http_proxy_connect_module
以上编译时，如出现缺少依赖，一般需要安装以下模块，安装完再次编译：
yum -y install libxml2 libxml2-dev libxslt-devel
yum -y install gd-devel
yum -y install perl-devel perl-ExtUtils-Embed
yum -y install GeoIP GeoIP-devel GeoIP-data
5、编译通过，继续验证
继续输入：make -j2
禁止：千万不要继续输入“make install”，以免现在的nginx出现问题
以上完成后，会在objs目录下生成一个nginx文件，先验证：
objs/nginx -t
objs/nginx -V
6、文件替换，并重启
以上成功后：
cp objs/nginx /usr/sbin/
nginx -s reload

nginx增加ngx_http_proxy_connect_module之前需要使用patch命令修补文件，在使用patch命令前一定要先进入解压后的nginx的根目录
patch -p1命令会忽略掉补丁文件中第1个”/”之前的内容，认为原始文件是 ./A，这样就正确了。
wget http://nginx.org/download/nginx-1.9.2.tar.gz
tar -xzvf nginx-1.9.2.tar.gz
cd nginx-1.9.2/
patch -p1 < /path/to/ngx_http_proxy_connect_module/patch/proxy_connect.patch
./configure --add-module=/path/to/ngx_http_proxy_connect_module
make && make install

#############################################yum install nginx#############################################

#############################################Nginx编译安装Lua模块#############################################
1、LuaJIT
wget http://luajit.org/download/LuaJIT-2.0.2.tar.gz
tar -xzvf LuaJIT-2.0.2.tar.gz
cd LuaJIT-2.0.5
make install PREFIX=/usr/local/LuaJIT
export LUAJIT_LIB=/usr/local/LuaJIT/lib
export LUAJIT_INC=/usr/local/LuaJIT/include/luajit-2.0
2、加载lua库，加入到ld.so.conf文件
echo "/usr/local/LuaJIT/lib" >> /etc/ld.so.conf
然后执行如下命令：
ldconfig
3、ngx_devel_kit和lua-nginx-module
wget https://github.com/simpl/ngx_devel_kit/archive/v0.3.0.tar.gz
wget https://github.com/openresty/lua-nginx-module/archive/v0.10.9rc7.tar.gz
分别解压
4、重新编译编译Nginx
./configure --prefix=/etc/nginx --sbin-path=/usr/sbin/nginx --modules-path=/usr/lib64/nginx/modules --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/run/nginx.pid --lock-path=/var/run/nginx.lock --http-client-body-temp-path=/var/cache/nginx/client_temp --http-proxy-temp-path=/var/cache/nginx/proxy_temp --http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp --http-scgi-temp-path=/var/cache/nginx/scgi_temp --user=nginx --group=nginx --with-compat --with-file-aio --with-threads --with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-mail --with-mail_ssl_module --with-stream --with-stream_realip_module --with-stream_ssl_module --with-stream_ssl_preread_module --with-cc-opt='-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches -m64 -mtune=generic -fPIC' --with-ld-opt='-Wl,-z,relro -Wl,-z,now -pie' --add-module=/home/nginx-sticky-module-ng --add-module=/home/ngx_devel_kit-0.3.0 --add-module=/home/lua-nginx-module-0.10.9rc7
#############################################Nginx编译安装Lua模块#############################################