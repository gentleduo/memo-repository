TCP报文格式详解

TCP报文是TCP层传输的数据单元，也叫报文段。
1、端口号：用来标识同一台计算机的不同的应用进程；占2个字节，16比特的端口号加上32比特的IP地址，共同构成相当于传输层服务访问点的地址，即“插口”。
1）源端口：源端口和IP地址的作用是标识报文的返回地址。
2）目的端口：端口指明接收方计算机上的应用程序接口。
TCP报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP唯一确定一条TCP连接。
2、序号和确认号：各占4个字节，是TCP可靠传输的关键部分。序号是本报文段发送的数据组的第一个字节的序号。在TCP传送的流中，每一个字节一个序号。e.g.一个报文段的序号为300，此报文段数据部分共有100字节，则下一个报文段的序号为400。所以序号确保了TCP传输的有序性。确认号，即ACK，指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。确认号只有当ACK标志为1时才有效。比如建立连接时，SYN报文的ACK标志位为0。
3、数据偏移／首部长度：4bits。由于首部可能含有可选项内容，因此TCP报头的长度是不确定的，报头不包含任何任选字段则长度为20字节，4位首部长度字段所能表示的最大值为1111，转化为10进制为15，15*32/8=60，故报头最大长度为60字节。首部长度也叫数据偏移，是因为首部长度实际上指示了数据区在报文段中的起始偏移值。
4、保留：为将来定义新的用途保留，现在一般置0。
5、控制位：URG ACK PSH RST SYN FIN，共6个，每一个标志位表示一个控制功能。
1）URG(urgent-紧急)：紧急指针标志，为1时表示紧急指针有效，为0则忽略紧急指针。
2）ACK(acknowledgement-确认)：确认序号标志，为1时表示确认号有效，为0表示报文中不含确认信息，忽略确认号字段。
3）PSH(push-传送)：push标志，为1表示是带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将这个报文段交给应用程序，而不是在缓冲区排队。
4）RST(reset-重置)：重置连接标志，用于重置由于主机崩溃或其他原因而出现错误的连接。或者用于拒绝非法的报文段和拒绝连接请求。
5）SYN(synchronous-建立联机)：同步序号，用于建立连接过程，在连接请求中，SYN=1和ACK=0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN=1和ACK=1。
6）FIN(finish-结束)：finish标志，用于释放连接，为1时表示发送方已经没有数据发送了，即关闭本方数据流。
6、窗口：滑动窗口大小，用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小时一个16bit字段，因而窗口大小最大为65535。
7、校验和：奇偶校验，此校验和是对整个的TCP报文段，包括TCP头部和TCP数据，以16位字进行计算所得。由发送端计算和存储，并由接收端进行验证。
8、紧急指针：只有当URG标志置1时紧急指针才有效。紧急指针是一个正的偏移量，和顺序号字段中的值相加表示紧急数据最后一个字节的序号。TCP的紧急方式是发送端向另一端发送紧急数据的一种方式。
9、选项和填充：最常见的可选字段是最长报文大小，又称为MSS（Maximum-Segment-Size），每个连接方通常都在通信的第一个报文段（为建立连接而设置SYN标志为1的那个段）中指明这个选项，它表示本端所能接受的最大报文段的长度。选项长度不一定是32位的整数倍，所以要加填充位，即在这个字段中加入额外的零，以保证TCP头是32的整数倍。
10、数据部分：TCP报文段中的数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有TCP首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。

三次握手过程：
1、主机A发送位码为SYN＝1,随机产生Seq Number=XXX的数据包到服务器，主机B由SYN＝1知道，A要求建立联机，主机A的状态变味SYN_SENT； 
2、主机B收到请求后要确认联机信息，向A发送Ack Number=(主机A的Seq+1),SYN=1,ACK=1,随机产生Seq Number=YYY的包，此时主机B的状态变为SYN_RCVD； 
3、主机A收到后检查Ack Number是否正确，即第一次发送的Seq Number+1,以及位码ACK是否为1，若正确，主机A状态变为ESTABLISHED；主机A会再发送Ack Number=(主机B的Seq Number+1),ACK=1，主机B收到后确认Ack Number与ACK=1，若正确，主机B状态变为ESTABLISHED，连接建立成功； 

四次挥手的过程：
挥手之前主动释放连接的客户端结束ESTABLISHED阶段。随后开始“四次挥手”：
1、首先客户端想要释放连接，向服务器端发送一段TCP报文，其中：
标记位为FIN，表示“请求释放连接“；
序号为Seq=U；
随后客户端进入FIN-WAIT-1阶段，即半关闭阶段。并且停止在客户端到服务器端方向上发送数据，但是客户端仍然能接收从服务器端传输过来的数据。
注意：这里不发送的是正常连接时传输的数据(非确认报文)，而不是一切数据，所以客户端仍然能发送ACK确认报文。
2、服务器端接收到从客户端发出的TCP报文之后，确认了客户端想要释放连接，随后服务器端结束ESTABLISHED阶段，进入CLOSE-WAIT阶段（半关闭状态）并返回一段TCP报文，其中：
标记位为ACK，表示“接收到客户端发送的释放连接的请求”；
序号为Seq=V；
确认号为Ack=U+1，表示是在收到客户端报文的基础上，将其序号Seq值加1作为本段报文确认号Ack的值；
随后服务器端开始准备释放服务器端到客户端方向上的连接。
客户端收到从服务器端发出的TCP报文之后，确认了服务器收到了客户端发出的释放连接请求，随后客户端结束FIN-WAIT-1阶段，进入FIN-WAIT-2阶段
前"两次挥手"既让服务器端知道了客户端想要释放连接，也让客户端知道了服务器端了解了自己想要释放连接的请求。于是，可以确认关闭客户端到服务器端方向上的连接了
3、服务器端自从发出ACK确认报文之后，经过CLOSED-WAIT阶段，做好了释放服务器端到客户端方向上的连接准备，再次向客户端发出一段TCP报文，其中：
标记位为FIN，ACK，表示“已经准备好释放连接了”。注意：这里的ACK并不是确认收到客户端报文的确认报文。
序号为Seq=W；
确认号为Ack=U+1；表示是在收到客户端报文的基础上，将其序号Seq值加1作为本段报文确认号Ack的值。
随后服务器端结束CLOSE-WAIT阶段，进入LAST-ACK阶段。并且停止在服务器端到客户端的方向上发送数据，但是服务器端仍然能够接收从客户端传输过来的数据。
4、客户端收到从服务器端发出的TCP报文，确认了服务器端已做好释放连接的准备，结束FIN-WAIT-2阶段，进入TIME-WAIT阶段，并向服务器端发送一段报文，其中：
标记位为ACK，表示“接收到服务器准备好释放连接的信号”。
序号为Seq=U+1；表示是在收到了服务器端报文的基础上，将其确认号Ack值作为本段报文序号的值。
确认号为Ack=W+1；表示是在收到了服务器端报文的基础上，将其序号Seq值作为本段报文确认号的值。
随后客户端开始在TIME-WAIT阶段等待2MSL
上述1之后到4之前客户端到服务端的TCP报文中的Seq Number将不再变化（都是U），因为客户端再发送完释放连接的报文后将停止在客户端到服务器端方向上发送数据
上述2到3的过程中服务器往客户端的报文中的序号由V增大到了W，这是因为服务器在收到了客户端发送的FIN报文后先向客户端回一个ACK报文段，然后会观察自己是否还有数据没有发送给客户端，如果有，先把数据发送给客户端再发送FIN报文。在2之后由于服务器端有可能再向客户端发送了数据所以3的报文中序号可能会大于2中的序号

Seq-Number代表的是发出的并且被对方确认好的数据长度
Ack-Number代表的是自己接受到的并且确认好的数据长度
上述1表示在发送FIN之前，客户端发送给服务器并且完成确认的数据的长度为：U
上述2表示服务器接受到客户端的FIN请求并完成确认，此时客户端发送给服务器并且完成确认的数据的长度为：U + 1（服务器发送给客户端并且完成确认的数据的长度为：v）
在上述2之后假设服务器还有3个数据包需要发送给客户端，流程如下所示：
数据包1：服务器到客户端的Seq-Number=v+L1,Ack-Number=U+1;客户端响应的Seq-Number=U+1;Ack-Number=v+L1（客户端只是单纯确认从服务器接收的数据无任何数据发送到服务器）
数据包2：服务器到客户端的Seq-Number=v+L1+L2,Ack-Number=U+1;客户端响应的Seq-Number=U+1;Ack-Number=v+L1+L2
数据包3：服务器到客户端的Seq-Number=v+L1+L2+L3,Ack-Number=U+1;客户端响应的Seq-Number=U+1;Ack-Number=v+L1+L2+L3
注意：由于只有在发送数据、或者无数据传输且位码SYN=1或FIN=1时并且在收到对方的Ack-Number之后才会改变Seq-Number；而在上述数据包1到数据包3的过程中客户端的响应包只是确认从服务器传输过来的数据，所以服务器报文中的Ack-Number和客户端报文中的Seq-Number是不再变化的

#################################################################################################################################
1、当内核从Client端的应用程序收到Close Signal（及应用程序调用socket.close()），首先会往对端(即Server端)发送一个FIN包，接着将自身的状态置为 FIN_WAIT_1；
2、服务器收到FIN后向客户端发送ACK，服务器的状态变为CLOSE_WAIT；
3、客户端收到ACK后就进入FIN_WAIT_2状态，此时连接已经断开了一半了。如果服务器还有数据要发送给客户端，就会继续发送；
4、直到发完数据，就会发送FIN报文，此时服务器进入LAST_ACK状态；
5、客户端收到服务器的FIN后，马上发送ACK给服务器，此时客户端进入TIME_WAIT状态； 
6、再过了2MSL长的时间后进入CLOSED状态。服务器收到客户端的ACK就进入CLOSED状态。
注意，在通过TCP四次挥手来关闭已建立的TCP连接的过程中，我的理解socket连接一直是没有关闭的，否则双方是无法进行通行的，比如说在上述的第一步中客户端就把socket连接关闭了的话那就无法收到第二步中服务器发送给客户端的ACK确认信号了；socket真正的关闭要到第六步，在四次挥手全部完成后。
#################################################################################################################################

计算规则：
Seq Number为序列号
Ack Number为应答号
Seq Number=对方上次的Ack Number；（首次发送时Seq Number为系统随机生成）
Ack Number=对方的Seq Number+1（无数据传输时且位码SYN＝1或FIN＝1）或者Seq Number+L（报文数据的长度L） 

状态迁移过程：
　　客户端：
　　　　CLOSED->SYN_SENT->ESTABLISHED->FIN_WAIT_1->FIN_WAIT_2->TIME_WAIT->CLOSED
　　服务端
　　　　CLOSED->LISTEN->SYN_RECEIVED->ESTABLISHED->CLOSE_WAIT->LAST_ACK->CLOSE

为什么连接的时候是三次握手，关闭的时候却是四次握手？
因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

MSL是Maximum-Segment-Lifetime英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为tcp报文（segment）是ip数据报（datagram）的数据部分，而ip头中有一个TTL域，TTL是time-to-live的缩写，中文可以译为“生存时间”，这个生存时间是由源主机设置初始值但不是存的具体时间，而是存储了一个ip数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减1，当此值为0则数据报将被丢弃，同时发送ICMP报文通知源主机。RFC-793中规定MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟等。

TCP的序列号（Sequence Number）和确认号（Acknowledgment Number）
以下的示例通过Wireshark抓包来分析TCP序列号和确认号。示例中仅包含一个单独的HTTP请求，请求的流程是：web浏览器向web服务器请求一个单独的图片文件，服务器返回一个成功的响应（HTTP/1.1200 OK），响应中包含请求的文件。
右键示例文件中任意一个TCP包并且选择Follow TCP Stream就可在单独的窗口查看原始的TCP流（客户端请求使用红色显示，服务端响应使用蓝色显示）

TCP三次握手
TCP在其协议头中使用大量的标志位或者说1位（bit）布尔域来控制连接状态，我们最感兴趣的3个标志位如下：
SYN - 创建一个连接
FIN -  终结一个连接
ACK - 确认接收到的数据
选择Wireshark中的“包”1并且展开中间面板的TCP层（Transmission-Control-Protocol）解析，然后展开TCP头中的标志位域，这里我们可以看见所有解析出来的TCP标志位，需要注意的是，“包1”设置了SYN标志位
使用同样的方式操作“包2”。可以看到"包2"设置了2个标志位：ACK - 用来确认收到客户端的SYN包，SYN - 用来表明服务端也希望建立TCP连接
从客户端发来的“包3”只设置了ACK标志位。这3个包完成了最初的TCP3次握手

序列号（Sequence Number）和确认号（Acknowledgement Number）：
TCP会话的每一端都包含一个32位（bit）的序列号，该序列号被用来跟踪该端发送的数据量。每一个包中都包含序列号，在接收端则通过确认号用来通知发送端数据成功接收。
当某个主机开启一个TCP会话时，他的初始序列号是随机的，可能是0和4,294,967,295之间的任意值，然而，像Wireshark这种工具，通常显示的都是相对序列号/确认号，而不是实际序列号/确认号，相对序列号/确认号是和TCP会话的初始序列号相关联的。这是很方便的，因为比起真实序列号/确认号，跟踪更小的相对序列号/确认号会相对容易一些。
比如，在“包1”中，最初的相对序列号的值是0，但是最下方面板中的ASCII码显示真实序列号的值是0xf61c6cbe，转化为10进制为4129057982
如果想要关闭相对序列号/确认号，可以选择Wireshark菜单栏中的Edit->Preferences->protocols->TCP，去掉Relative-sequence-number后面勾选框中的√即可
需要注意的是，接下来的部分依然使用相对序列号/确认号
为了更好的理解在整个TCP会话期间，TCP序列号和确认号是如何工作的，我们可以使用Wireshark内置的绘制流功能，选择菜单栏中的Statistics->Flow-Graph...->TCP flow->OK（统计->流量图->TCP flow）
Wireshark会自动创建一个TCP流的图形摘要
每行代表一个单独的TCP包，左边列显示时间，中间列显示包的方向、TCP端口、段长度和设置的标志位，右边列以10进制的方式显示相关序列号/确认号，在这里选中任意行会高亮主窗口中该行所关联的包
我们可以利用这个流图更好的理解序列号和确认号是如何工作的
包1：
TCP会话的每一端的序列号都从0开始，同样的，确认号也从0开始，因为此时通话还未开始，没有通话的另一端需要确认
包2：
服务端响应客户端的请求，响应中附带序列号0（由于这是服务端在该次TCP会话中发送的第一个包，所以序列号为0）和相对确认号1（表明服务端收到了客户端发送的包1中的SYN）
包3：
和包2中一样，客户端使用确认号1响应服务端的序列号0，同时响应中也包含了客户端自己的序列号（由于服务端发送的包中确认收到了客户端发送的SYN，故客户端的序列号由0变为1）
此时，通信的两端的序列号都为1，通信两端的序列号增1发生在所有TCP会话的建立过程中
包4：
这是流中第一个携带有效数据的包（确切的说，是客户端发送的HTTP请求），序列号依然为1，因为到上个包为止，还没有发送任何数据，确认号也保持1不变，因为客户端没有从服务端接收到任何数据
需要注意的是，包中有效数据的长度为725字节
包5：
当上层处理HTTP请求时，服务端发送该包来确认客户端在包4中发来的数据，需要注意的是，确认号的值增加了725（725是包4中有效数据长度），变为726，简单来说，服务端以此来告知客户端端，目前为止，我总共收到了726字节的数据，服务端的序列号保持为1不变
包6：
这个包标志着服务端返回HTTP响应的开始，序列号依然为1，因为服务端在该包之前返回的包中都不带有有效数据，该包带有1448字节的有效数据
包7：
由于上个数据包的发送，TCP客户端的序列号增长至726，从服务端接收了1448字节的数据，客户端的确认号由1增长至1449
在抓包文件的主体部分，我们可以看到上述过程的不断的重复，客户端的序列号一直是726，因为客户端除了最初的725字节数据没有再向服务端发送数据，服务端的序列号则与此相反，由于服务端不断的发送HTTP响应，故其序列号一直在增长
序列号为当前端成功发送的数据位数，确认号为当前端成功接收的数据位数，SYN标志位和FIN标志位也要占1位
包38：
在确认了服务端发送过来的最后一个数据段之后，客户端将处理整个HTTP响应并决定不需要进一步通信了。此时客户端发送设置了FIN标志位的包38，其确认号和之前的包37一样
包39：
服务端通过将确认号加1的方式回应客户端期望关闭连接的请求（这里和包2中确认SYN标志位时所作的操作是一样的），同时设置当前包的FIN标志位
包40：
客户端发送最终序列号727，通过将确认号加1的方式确认服务端的FIN包
此时，通信双方都终结了会话并且可以释放用于维持会话所占用的资源